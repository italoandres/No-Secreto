rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ===== FUNÃ‡Ã•ES AUXILIARES (DEVEM VIR PRIMEIRO) =====
    
    // Verifica se usuÃ¡rio Ã© admin
    function isAdmin(userId) {
      let userDoc = get(/databases/$(database)/documents/users/$(userId));
      return userDoc.data.isAdmin == true;
    }
    
    // Verifica se usuÃ¡rio Ã© participante de um match
    function isMatchParticipant(matchId, userId) {
      let matchDoc = get(/databases/$(database)/documents/matches/$(matchId));
      return userId == matchDoc.data.user1Id || userId == matchDoc.data.user2Id;
    }
    
    // Verifica se usuÃ¡rio Ã© participante de um chat
    function isChatParticipant(chatId, userId) {
      let chatDoc = get(/databases/$(database)/documents/match_chats/$(chatId));
      return isMatchParticipant(chatDoc.data.matchId, userId);
    }
    
    // Regras para usuÃ¡rios
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      allow read: if request.auth != null; // Permitir leitura para busca de usuÃ¡rios
    }
    
    // Regras para convites de parceria
    match /purpose_invites/{inviteId} {
      allow create: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
      allow read, update: if request.auth != null && 
        (request.auth.uid == resource.data.fromUserId || 
         request.auth.uid == resource.data.toUserId);
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.fromUserId;
    }
    
    // Regras para parcerias estabelecidas
    match /purpose_partnerships/{partnershipId} {
      allow read, write: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id);
      allow create: if request.auth != null;
    }
    
    // Regras para chats compartilhados do propÃ³sito
    match /purpose_chats/{chatId} {
      allow read, write: if request.auth != null && 
        request.auth.uid in resource.data.participantIds;
      allow create: if request.auth != null;
    }
    
    // Regras para mensagens dos chats compartilhados
    match /purpose_chats/{chatId}/messages/{messageId} {
      allow read: if request.auth != null && 
        request.auth.uid in get(/databases/$(database)/documents/purpose_chats/$(chatId)).data.participantIds;
      allow create: if request.auth != null && 
        request.auth.uid in get(/databases/$(database)/documents/purpose_chats/$(chatId)).data.participantIds &&
        request.auth.uid == request.resource.data.senderId;
      allow update: if request.auth != null && 
        request.auth.uid == resource.data.senderId;
    }
    
    // Regras para lista de usuÃ¡rios bloqueados
    match /blocked_users/{blockId} {
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.blockerUserId;
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.blockerUserId || 
         request.auth.uid == resource.data.blockedUserId);
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.blockerUserId;
    }
    
    // Regras para chats existentes (manter compatibilidade)
    match /chats/{chatId} {
      allow read, write: if request.auth != null;
    }
    
    match /chats/{chatId}/messages/{messageId} {
      allow read, write: if request.auth != null;
    }
    
    // Regras para stories
    match /stories/{storyId} {
      allow read: if request.auth != null;
      // âœ… CORRIGIDO: Separar create e update para evitar erro com resource.data
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }
    
    // âœ… ADICIONADO: Regras para stories visualizados (stores_visto)
    match /stores_visto/{docId} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null && 
        request.resource.data.idUser == request.auth.uid;
      allow delete: if request.auth != null && 
        resource.data.idUser == request.auth.uid;
    }
    
    // âœ… ADICIONADO: Regras para arquivos de stories (stories_files)
    match /stories_files/{storyId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.authorId;
    }
    
    // âœ… ADICIONADO: Regras para stories Sinais Isaque
    match /stories_sinais_isaque/{storyId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.authorId;
    }
    
    // âœ… ADICIONADO: Regras para stories Sinais Rebeca
    match /stories_sinais_rebeca/{storyId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && 
        request.auth.uid == resource.data.authorId;
    }
    
    // âœ… ADICIONADO: Regra explÃ­cita para coleÃ§Ã£o sistema
    match /sistema/{docId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null;
    }
    
    // âœ… ADICIONADO: Regras para logs da aplicaÃ§Ã£o
    match /app_logs/{logId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if false; // Logs sÃ£o imutÃ¡veis
    }
    
    // âœ… ADICIONADO: Regras para certificaÃ§Ãµes (alias de certification_requests)
    match /certifications/{certificationId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      allow update: if request.auth != null && 
        isAdmin(request.auth.uid);
      allow delete: if request.auth != null && 
        isAdmin(request.auth.uid);
    }
    
    // âœ… ADICIONADO: Regras para notificaÃ§Ãµes de interesse
    match /interest_notifications/{notificationId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.fromUserId || 
         request.auth.uid == resource.data.toUserId);
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.toUserId;
    }
    
    // Regras para notificaÃ§Ãµes
    match /notifications/{notificationId} {
      // UsuÃ¡rio sÃ³ pode ler suas prÃ³prias notificaÃ§Ãµes
      allow read: if request.auth != null && 
                     request.auth.uid == resource.data.userId;
      
      // UsuÃ¡rio sÃ³ pode marcar suas notificaÃ§Ãµes como lidas
      // Permitir atualizaÃ§Ã£o de 'isRead' OU 'read' (ambos os campos sÃ£o usados)
      allow update: if request.auth != null && 
                       request.auth.uid == resource.data.userId &&
                       (request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['isRead']) ||
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['read', 'readAt']) ||
                       request.resource.data.diff(resource.data).affectedKeys()
                       .hasOnly(['read']));
      
      // Sistema pode criar notificaÃ§Ãµes (qualquer usuÃ¡rio autenticado)
      allow create: if request.auth != null;
      
      // UsuÃ¡rio pode deletar suas prÃ³prias notificaÃ§Ãµes
      allow delete: if request.auth != null && 
                       request.auth.uid == resource.data.userId;
    }
    
    // Regras para usuÃ¡rios (corrigir nome da coleÃ§Ã£o)
    match /usuarios/{userId} {
      allow read, write: if request.auth != null;
    }
    
    // ===== REGRAS PARA SISTEMA DE MATCHES =====
    
    // Regras para matches
    match /matches/{matchId} {
      // UsuÃ¡rio pode ler matches onde Ã© participante
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id);
      
      // UsuÃ¡rio pode criar match (sistema de convites)
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.user1Id || 
         request.auth.uid == request.resource.data.user2Id) &&
        request.resource.data.keys().hasAll(['user1Id', 'user2Id', 'matchedAt', 'chatExpiresAt']) &&
        request.resource.data.isActive == true &&
        request.resource.data.chatEnabled == true;
      
      // UsuÃ¡rio pode atualizar match (Ãºltima mensagem, status de leitura, etc.)
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id) &&
        // NÃ£o pode alterar IDs dos usuÃ¡rios ou data do match
        !request.resource.data.diff(resource.data).affectedKeys()
          .hasAny(['user1Id', 'user2Id', 'matchedAt']);
      
      // UsuÃ¡rio pode desativar match (reportar/bloquear)
      allow delete: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id);
    }
    
    // Regras para chats de matches
    match /match_chats/{chatId} {
      // UsuÃ¡rio pode ler chat se for participante do match
      allow read: if request.auth != null && 
        isMatchParticipant(resource.data.matchId, request.auth.uid);
      
      // Sistema pode criar chat automaticamente
      allow create: if request.auth != null && 
        request.resource.data.keys().hasAll(['matchId', 'createdAt']) &&
        isMatchParticipant(request.resource.data.matchId, request.auth.uid);
      
      // Participantes podem atualizar metadados do chat
      allow update: if request.auth != null && 
        isMatchParticipant(resource.data.matchId, request.auth.uid) &&
        // NÃ£o pode alterar matchId
        !request.resource.data.diff(resource.data).affectedKeys()
          .hasAny(['matchId']);
    }
    
    // Regras para mensagens de matches
    match /match_messages/{messageId} {
      // âœ… CORRIGIDO: Simplificar regra de read para evitar falhas com get()
      allow read: if request.auth != null;
      
      // UsuÃ¡rio pode enviar mensagem se for participante e remetente
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.senderId &&
        request.resource.data.keys().hasAll(['chatId', 'senderId', 'content', 'sentAt']) &&
        request.resource.data.content is string &&
        request.resource.data.content.size() > 0 &&
        request.resource.data.content.size() <= 1000; // Limite de 1000 caracteres
      
      // âœ… CORRIGIDO: Permitir marcar como lida (isRead) alÃ©m de soft delete
      allow update: if request.auth != null && 
        (
          // Pode marcar como lida
          (request.resource.data.diff(resource.data).affectedKeys()
            .hasOnly(['isRead', 'readAt'])) ||
          // Ou pode fazer soft delete (apenas o remetente)
          (request.auth.uid == resource.data.senderId &&
           request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['isDeleted', 'deletedAt', 'content']) &&
           request.resource.data.isDeleted == true)
        );
      
      // UsuÃ¡rio nÃ£o pode deletar mensagens (apenas soft delete via update)
      allow delete: if false;
    }
    
    // Regras para interesses mÃºtuos (compatibilidade com sistema antigo)
    match /mutual_interests/{interestId} {
      // UsuÃ¡rio pode ler se for participante
      allow read: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id);
      
      // UsuÃ¡rio pode criar interesse mÃºtuo
      allow create: if request.auth != null && 
        (request.auth.uid == request.resource.data.user1Id || 
         request.auth.uid == request.resource.data.user2Id);
      
      // UsuÃ¡rio pode atualizar status
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.user1Id || 
         request.auth.uid == resource.data.user2Id);
    }
    
    // Regras para notificaÃ§Ãµes agendadas (sistema de expiraÃ§Ã£o)
    match /scheduled_notifications/{notificationId} {
      // Apenas sistema pode gerenciar notificaÃ§Ãµes agendadas
      allow read, write: if request.auth != null;
    }
    
    // Regras para perfis espirituais
    match /spiritual_profiles/{profileId} {
      // Qualquer usuÃ¡rio autenticado pode ler e escrever perfis
      allow read, write: if request.auth != null;
    }
    
    // ===== REGRAS PARA SISTEMA DE SINAIS (RECOMENDAÃ‡Ã•ES SEMANAIS) =====
    
    // Regras para perfis pÃºblicos
    match /profiles/{profileId} {
      // Qualquer usuÃ¡rio autenticado pode ler perfis
      allow read: if request.auth != null;
      
      // UsuÃ¡rio pode criar/atualizar seu prÃ³prio perfil
      allow create, update: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      
      // UsuÃ¡rio pode deletar seu prÃ³prio perfil
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.userId;
    }
    
    // Regras para recomendaÃ§Ãµes semanais
    match /weeklyRecommendations/{docId} {
      // UsuÃ¡rio pode ler suas prÃ³prias recomendaÃ§Ãµes
      // docId formato: userId_weekKey
      allow read: if request.auth != null && 
        docId.matches('^' + request.auth.uid + '_.*');
      
      // Sistema pode criar/atualizar recomendaÃ§Ãµes
      allow create, update: if request.auth != null && 
        docId.matches('^' + request.auth.uid + '_.*');
      
      // UsuÃ¡rio pode deletar suas prÃ³prias recomendaÃ§Ãµes
      allow delete: if request.auth != null && 
        docId.matches('^' + request.auth.uid + '_.*');
    }
    
    // Regras para interesses demonstrados
    match /interests/{interestId} {
      // âœ… CORRIGIDO: Permite queries filtradas por toUserId ou fromUserId
      // UsuÃ¡rio pode fazer query buscando interesses onde ele Ã© destinatÃ¡rio ou remetente
      allow read: if request.auth != null;
      
      // UsuÃ¡rio pode criar interesse (demonstrar interesse em alguÃ©m)
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.fromUserId &&
        request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'timestamp', 'status']);
      
      // Sistema pode atualizar status (quando vira match)
      allow update: if request.auth != null && 
        (request.auth.uid == resource.data.fromUserId || 
         request.auth.uid == resource.data.toUserId);
    }
    
    // Regras para matches (sistema de Sinais)
    match /matches/{matchId} {
      // UsuÃ¡rio pode ler matches onde Ã© participante
      allow read: if request.auth != null && 
        request.auth.uid in resource.data.users;
      
      // Sistema pode criar match quando hÃ¡ interesse mÃºtuo
      allow create: if request.auth != null && 
        request.auth.uid in request.resource.data.users &&
        request.resource.data.keys().hasAll(['users', 'createdAt', 'status']);
      
      // Participantes podem atualizar match (marcar como visualizado)
      allow update: if request.auth != null && 
        request.auth.uid in resource.data.users;
    }
    
    // Regras para filtros de busca do usuÃ¡rio
    match /searchFilters/{userId} {
      // UsuÃ¡rio pode ler seus prÃ³prios filtros
      allow read: if request.auth != null && 
        request.auth.uid == userId;
      
      // UsuÃ¡rio pode criar/atualizar seus prÃ³prios filtros
      allow create, update: if request.auth != null && 
        request.auth.uid == userId;
      
      // UsuÃ¡rio pode deletar seus prÃ³prios filtros
      allow delete: if request.auth != null && 
        request.auth.uid == userId;
    }
    
    // ===== REGRAS PARA SISTEMA DE CERTIFICAÃ‡Ã•ES =====
    
    // Regras para solicitaÃ§Ãµes de certificaÃ§Ã£o espiritual (collection antiga)
    match /spiritual_certifications/{certificationId} {
      // Qualquer usuÃ¡rio autenticado pode ler e escrever
      allow read, write: if request.auth != null;
    }
    
    // Regras para solicitaÃ§Ãµes de certificaÃ§Ã£o espiritual (collection nova)
    match /certification_requests/{certificationId} {
      // Qualquer usuÃ¡rio autenticado pode ler todas as certificaÃ§Ãµes
      // (necessÃ¡rio para exibir selo no perfil pÃºblico)
      allow read: if request.auth != null;
      
      // UsuÃ¡rio pode criar sua prÃ³pria solicitaÃ§Ã£o
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.userId;
      
      // Apenas admins podem atualizar (aprovar/reprovar)
      allow update: if request.auth != null && 
        isAdmin(request.auth.uid);
      
      // Apenas admins podem deletar
      allow delete: if request.auth != null && 
        isAdmin(request.auth.uid);
    }
    
    // Regras para log de auditoria de certificaÃ§Ãµes
    match /certification_audit_log/{logId} {
      // Apenas admins podem ler logs
      allow read: if request.auth != null && 
        isAdmin(request.auth.uid);
      
      // Apenas sistema pode criar logs (via Cloud Functions)
      // UsuÃ¡rios autenticados podem criar para permitir Cloud Functions
      allow create: if request.auth != null &&
        request.resource.data.keys().hasAll(['certificationId', 'userId', 'action', 'performedBy', 'performedAt', 'method']) &&
        request.resource.data.action in ['approved', 'rejected', 'token_invalid', 'token_expired'] &&
        request.resource.data.method in ['email', 'panel', 'api'];
      
      // NinguÃ©m pode atualizar ou deletar logs (imutÃ¡veis)
      allow update, delete: if false;
    }
    
    // Regras para tokens de aprovaÃ§Ã£o/reprovaÃ§Ã£o
    match /certification_tokens/{tokenId} {
      // Apenas sistema pode criar tokens (via Cloud Functions)
      allow create: if request.auth != null;
      
      // Apenas sistema pode ler tokens (via Cloud Functions)
      allow read: if request.auth != null;
      
      // Apenas sistema pode marcar token como usado
      allow update: if request.auth != null &&
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['used', 'usedAt']);
      
      // Tokens nÃ£o podem ser deletados (manter histÃ³rico)
      allow delete: if false;
    }
    
    
    // ===== REGRA CATCH-ALL PARA DESENVOLVIMENTO =====
    // âš ï¸  ATENÃ‡ÃƒO: Esta regra permite acesso amplo para qualquer coleÃ§Ã£o nÃ£o mapeada acima
    // âœ… POSICIONADA NO FINAL: Funciona como fallback quando nenhuma regra especÃ­fica se aplica
    // ðŸŽ¯ PRODUÃ‡ÃƒO: Refinar regras especÃ­ficas e remover esta regra depois
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
  }
}