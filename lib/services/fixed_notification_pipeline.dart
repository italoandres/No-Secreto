import 'dart:async';
import 'package:get/get.dart';
import '../models/real_notification_model.dart';
import '../models/interest_model.dart';
import '../models/user_data_model.dart';
import '../utils/enhanced_logger.dart';
import '../controllers/matches_controller.dart';
import '../services/javascript_error_handler.dart';
import '../repositories/enhanced_real_interests_repository.dart';
import '../services/temp_notification_converter.dart';
import '../services/error_recovery_system.dart';
import '../services/real_time_sync_manager.dart';

/// Pipeline corrigido para processamento de intera√ß√µes em notifica√ß√µes
class FixedNotificationPipeline {
  static FixedNotificationPipeline? _instance;
  static FixedNotificationPipeline get instance =>
      _instance ??= FixedNotificationPipeline._();

  FixedNotificationPipeline._();

  bool _isInitialized = false;
  bool _isProcessing = false;
  final Map<String, UserData> _userCache = {};
  final List<String> _processingLog = [];

  /// Inicializa o pipeline corrigido
  void initialize() {
    if (_isInitialized) return;

    try {
      // Inicializa todos os componentes
      JavaScriptErrorHandler.instance.initialize();
      ErrorRecoverySystem.instance.initialize();
      RealTimeSyncManager.instance.initialize();

      _isInitialized = true;

      EnhancedLogger.success(
          '‚úÖ [FIXED_PIPELINE] Pipeline inicializado com sucesso');
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro ao inicializar pipeline',
          error: e);
    }
  }

  /// Processa intera√ß√µes de forma robusta e corrigida
  Future<List<RealNotification>> processInteractionsRobustly(
      String userId) async {
    if (_isProcessing) {
      EnhancedLogger.warning(
          '‚ö†Ô∏è [FIXED_PIPELINE] Processamento j√° em andamento');
      return [];
    }

    _isProcessing = true;
    _processingLog.clear();

    try {
      EnhancedLogger.info('üöÄ [FIXED_PIPELINE] Iniciando processamento robusto',
          tag: 'FIXED_NOTIFICATION_PIPELINE',
          data: {
            'userId': userId,
            'timestamp': DateTime.now().toIso8601String(),
            'pipelineInitialized': _isInitialized
          });

      _addToLog('Iniciando processamento para usu√°rio: $userId');

      // ETAPA 1: Busca intera√ß√µes com retry robusto
      final interests = await _fetchInteractionsWithValidation(userId);
      _addToLog(
          'Etapa 1 conclu√≠da: ${interests.length} intera√ß√µes encontradas');

      if (interests.isEmpty) {
        EnhancedLogger.warning(
            '‚ö†Ô∏è [FIXED_PIPELINE] Nenhuma intera√ß√£o encontrada');
        _addToLog('AVISO: Nenhuma intera√ß√£o encontrada');
        return [];
      }

      // ETAPA 2: Pr√©-carrega dados dos usu√°rios
      await _preloadUserData(interests);
      _addToLog(
          'Etapa 2 conclu√≠da: Dados de ${_userCache.length} usu√°rios carregados');

      // ETAPA 3: Converte intera√ß√µes em notifica√ß√µes
      final notifications = await _convertWithValidation(interests);
      _addToLog(
          'Etapa 3 conclu√≠da: ${notifications.length} notifica√ß√µes criadas');

      if (notifications.isEmpty) {
        EnhancedLogger.error(
            '‚ùå [FIXED_PIPELINE] PROBLEMA CR√çTICO: Convers√£o resultou em 0 notifica√ß√µes',
            data: {
              'originalInteractions': interests.length,
              'convertedNotifications': 0,
              'processingLog': _processingLog
            });

        // Tenta recupera√ß√£o de emerg√™ncia
        return await _emergencyRecovery(userId, interests);
      }

      // ETAPA 4: Valida notifica√ß√µes criadas
      final validNotifications = _validateNotifications(notifications);
      _addToLog(
          'Etapa 4 conclu√≠da: ${validNotifications.length} notifica√ß√µes v√°lidas');

      // ETAPA 5: Sincroniza com UI
      await _syncWithUI(validNotifications);
      _addToLog('Etapa 5 conclu√≠da: UI sincronizada');

      // ETAPA 6: Salva cache de fallback
      _saveFallbackCache(userId, validNotifications);
      _addToLog('Etapa 6 conclu√≠da: Cache de fallback salvo');

      EnhancedLogger.success(
          'üéâ [FIXED_PIPELINE] Processamento conclu√≠do com sucesso',
          data: {
            'userId': userId,
            'originalInteractions': interests.length,
            'finalNotifications': validNotifications.length,
            'conversionRate': interests.isNotEmpty
                ? (validNotifications.length / interests.length * 100)
                    .toStringAsFixed(2)
                : '0.00',
            'processingSteps': _processingLog.length,
            'processingLog': _processingLog
          });

      return validNotifications;
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro cr√≠tico no processamento',
          error: e, data: {'userId': userId, 'processingLog': _processingLog});

      // Tenta recupera√ß√£o de emerg√™ncia
      return await ErrorRecoverySystem.instance.recoverNotifications(userId);
    } finally {
      _isProcessing = false;
    }
  }

  /// ETAPA 1: Busca intera√ß√µes com valida√ß√£o rigorosa
  Future<List<Interest>> _fetchInteractionsWithValidation(String userId) async {
    try {
      EnhancedLogger.info('üîç [FIXED_PIPELINE] Etapa 1: Buscando intera√ß√µes',
          data: {'userId': userId});

      // Usa repository robusto com retry
      final interests = await EnhancedRealInterestsRepository.instance
          .getInterestsWithRetry(userId);

      EnhancedLogger.info('üìä [FIXED_PIPELINE] Intera√ß√µes brutas obtidas',
          data: {
            'userId': userId,
            'rawInteractions': interests.length,
            'interactionIds': interests.map((i) => i.id).take(5).toList()
          });

      // Valida√ß√£o adicional
      final validInterests = <Interest>[];
      for (final interest in interests) {
        if (_validateInteraction(interest)) {
          validInterests.add(interest);
        } else {
          EnhancedLogger.warning(
              '‚ö†Ô∏è [FIXED_PIPELINE] Intera√ß√£o inv√°lida ignorada',
              data: {
                'interactionId': interest.id,
                'fromUserId': interest.from,
                'toUserId': interest.to
              });
        }
      }

      EnhancedLogger.success('‚úÖ [FIXED_PIPELINE] Etapa 1 conclu√≠da', data: {
        'userId': userId,
        'rawInteractions': interests.length,
        'validInteractions': validInterests.length,
        'filteredOut': interests.length - validInterests.length
      });

      return validInterests;
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 1',
          error: e, data: {'userId': userId});
      rethrow;
    }
  }

  /// Valida uma intera√ß√£o individual
  bool _validateInteraction(Interest interest) {
    try {
      // Valida√ß√µes b√°sicas
      if (interest.id.isEmpty) return false;
      if (interest.from.isEmpty) return false;
      if (interest.to.isEmpty) return false;
      if (interest.from == interest.to) return false;

      // Valida√ß√£o de timestamp
      final now = DateTime.now();
      if (interest.timestamp.isAfter(now)) return false;

      // N√£o muito antiga (30 dias)
      final thirtyDaysAgo = now.subtract(const Duration(days: 30));
      if (interest.timestamp.isBefore(thirtyDaysAgo)) return false;

      return true;
    } catch (e) {
      return false;
    }
  }

  /// ETAPA 2: Pr√©-carrega dados dos usu√°rios
  Future<void> _preloadUserData(List<Interest> interests) async {
    try {
      EnhancedLogger.info(
          'üë• [FIXED_PIPELINE] Etapa 2: Pr√©-carregando dados dos usu√°rios');

      final userIds = interests.map((i) => i.from).toSet();

      EnhancedLogger.info('üìã [FIXED_PIPELINE] Usu√°rios √∫nicos identificados',
          data: {
            'uniqueUsers': userIds.length,
            'userIds': userIds.take(5).toList()
          });

      // Carrega dados de cada usu√°rio
      for (final userId in userIds) {
        if (!_userCache.containsKey(userId)) {
          try {
            final userData = await _loadUserData(userId);
            if (userData != null) {
              _userCache[userId] = userData;
            }
          } catch (e) {
            EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro ao carregar usu√°rio',
                error: e, data: {'userId': userId});

            // Cria dados b√°sicos como fallback
            _userCache[userId] = UserData(
              userId: userId,
              name: 'Usu√°rio',
              username: 'user_$userId',
              email: '$userId@example.com',
              photoUrl: null,
            );
          }
        }
      }

      EnhancedLogger.success('‚úÖ [FIXED_PIPELINE] Etapa 2 conclu√≠da', data: {
        'requestedUsers': userIds.length,
        'cachedUsers': _userCache.length,
        'newlyLoaded': _userCache.length
      });
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 2', error: e);
      rethrow;
    }
  }

  /// Carrega dados de um usu√°rio espec√≠fico
  Future<UserData?> _loadUserData(String userId) async {
    try {
      // Implementa√ß√£o simplificada - pode ser expandida para buscar do Firebase
      return UserData(
        userId: userId,
        name: 'üöÄ Sistema Teste', // Nome padr√£o para testes
        username: 'test_user_$userId',
        email: '$userId@test.com',
        photoUrl: null,
      );
    } catch (e) {
      return null;
    }
  }

  /// ETAPA 3: Converte intera√ß√µes com valida√ß√£o
  Future<List<RealNotification>> _convertWithValidation(
      List<Interest> interests) async {
    try {
      EnhancedLogger.info('üîÑ [FIXED_PIPELINE] Etapa 3: Convertendo intera√ß√µes',
          data: {
            'interactionsToConvert': interests.length,
            'userCacheSize': _userCache.length
          });

      // Usa converter robusto
      final converter = TempNotificationConverter.instance;
      final notifications = await converter.convertInteractionsToNotifications(
          interests, _userCache);

      EnhancedLogger.info('üìß [FIXED_PIPELINE] Convers√£o inicial conclu√≠da',
          data: {
            'originalInteractions': interests.length,
            'convertedNotifications': notifications.length,
            'conversionRate': interests.isNotEmpty
                ? (notifications.length / interests.length * 100)
                    .toStringAsFixed(2)
                : '0.00'
          });

      // Log detalhado das notifica√ß√µes criadas
      for (int i = 0; i < notifications.length && i < 5; i++) {
        final notification = notifications[i];
        EnhancedLogger.info('üìß [FIXED_PIPELINE] Notifica√ß√£o criada ${i + 1}',
            data: {
              'id': notification.id,
              'fromUser': notification.fromUserName,
              'message': notification.message,
              'timestamp': notification.timestamp.toIso8601String()
            });
      }

      return notifications;
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 3', error: e);
      rethrow;
    }
  }

  /// ETAPA 4: Valida notifica√ß√µes criadas
  List<RealNotification> _validateNotifications(
      List<RealNotification> notifications) {
    try {
      EnhancedLogger.info('‚úÖ [FIXED_PIPELINE] Etapa 4: Validando notifica√ß√µes',
          data: {'notificationsToValidate': notifications.length});

      final validNotifications = <RealNotification>[];

      for (final notification in notifications) {
        final converter = TempNotificationConverter.instance;
        if (converter.validateNotification(notification)) {
          validNotifications.add(notification);
        } else {
          EnhancedLogger.warning(
              '‚ö†Ô∏è [FIXED_PIPELINE] Notifica√ß√£o inv√°lida removida',
              data: {
                'notificationId': notification.id,
                'fromUser': notification.fromUserName
              });
        }
      }

      EnhancedLogger.success('‚úÖ [FIXED_PIPELINE] Etapa 4 conclu√≠da', data: {
        'originalNotifications': notifications.length,
        'validNotifications': validNotifications.length,
        'invalidRemoved': notifications.length - validNotifications.length
      });

      return validNotifications;
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 4', error: e);
      return notifications; // Retorna originais em caso de erro
    }
  }

  /// ETAPA 5: Sincroniza com UI
  Future<void> _syncWithUI(List<RealNotification> notifications) async {
    try {
      EnhancedLogger.info('üîÑ [FIXED_PIPELINE] Etapa 5: Sincronizando com UI',
          data: {'notificationsToSync': notifications.length});

      // Usa sync manager para atualiza√ß√£o inteligente
      RealTimeSyncManager.instance.syncNotificationsWithUI(notifications);

      // Aguarda um pouco para garantir que a UI foi atualizada
      await Future.delayed(const Duration(milliseconds: 100));

      // Verifica se a sincroniza√ß√£o foi bem-sucedida
      final controller = Get.find<MatchesController>();
      final syncedCount = controller.realNotifications.length;

      EnhancedLogger.success('‚úÖ [FIXED_PIPELINE] Etapa 5 conclu√≠da', data: {
        'notificationsSent': notifications.length,
        'notificationsSynced': syncedCount,
        'syncSuccessful': syncedCount == notifications.length
      });
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 5', error: e);
    }
  }

  /// ETAPA 6: Salva cache de fallback
  void _saveFallbackCache(String userId, List<RealNotification> notifications) {
    try {
      ErrorRecoverySystem.instance
          .saveFallbackNotifications(userId, notifications);

      EnhancedLogger.info(
          'üíæ [FIXED_PIPELINE] Etapa 6: Cache de fallback salvo',
          data: {'userId': userId, 'notificationCount': notifications.length});
    } catch (e) {
      EnhancedLogger.error('‚ùå [FIXED_PIPELINE] Erro na Etapa 6', error: e);
    }
  }

  /// Recupera√ß√£o de emerg√™ncia quando tudo falha
  Future<List<RealNotification>> _emergencyRecovery(
      String userId, List<Interest> originalInterests) async {
    try {
      EnhancedLogger.warning(
          'üö® [FIXED_PIPELINE] Executando recupera√ß√£o de emerg√™ncia',
          data: {
            'userId': userId,
            'originalInteractions': originalInterests.length
          });

      // Tenta convers√£o manual simples
      final emergencyNotifications = <RealNotification>[];

      for (final interest in originalInterests.take(5)) {
        // Limita a 5 para evitar sobrecarga
        try {
          final notification = RealNotification(
            id: interest.id,
            type: 'interest',
            fromUserId: interest.from,
            fromUserName: 'üöÄ Sistema Teste',
            fromUserPhoto: null,
            message: 'üöÄ Sistema Teste se interessou por voc√™',
            timestamp: interest.timestamp,
            isRead: false,
          );

          emergencyNotifications.add(notification);
        } catch (e) {
          EnhancedLogger.error(
              '‚ùå [FIXED_PIPELINE] Erro na convers√£o de emerg√™ncia',
              error: e,
              data: {'interestId': interest.id});
        }
      }

      if (emergencyNotifications.isNotEmpty) {
        // Sincroniza notifica√ß√µes de emerg√™ncia
        await _syncWithUI(emergencyNotifications);

        EnhancedLogger.success(
            '‚úÖ [FIXED_PIPELINE] Recupera√ß√£o de emerg√™ncia bem-sucedida',
            data: {
              'userId': userId,
              'emergencyNotifications': emergencyNotifications.length
            });
      }

      return emergencyNotifications;
    } catch (e) {
      EnhancedLogger.error(
          '‚ùå [FIXED_PIPELINE] Falha na recupera√ß√£o de emerg√™ncia',
          error: e);
      return [];
    }
  }

  /// Adiciona entrada ao log de processamento
  void _addToLog(String message) {
    final timestamp = DateTime.now().toIso8601String();
    _processingLog.add('[$timestamp] $message');

    // Mant√©m apenas os √∫ltimos 50 logs
    if (_processingLog.length > 50) {
      _processingLog.removeAt(0);
    }
  }

  /// Obt√©m estat√≠sticas do pipeline
  Map<String, dynamic> getPipelineStatistics() {
    return {
      'isInitialized': _isInitialized,
      'isProcessing': _isProcessing,
      'userCacheSize': _userCache.length,
      'processingLogSize': _processingLog.length,
      'recentProcessingLog': _processingLog.take(10).toList(),
      'timestamp': DateTime.now().toIso8601String(),
    };
  }

  /// Obt√©m log completo de processamento
  List<String> getProcessingLog() {
    return List.from(_processingLog);
  }

  /// Limpa cache e reinicia pipeline
  void reset() {
    _userCache.clear();
    _processingLog.clear();
    _isProcessing = false;

    EnhancedLogger.info('üîÑ [FIXED_PIPELINE] Pipeline resetado');
  }
}
