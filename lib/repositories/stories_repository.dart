
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
// import 'package:ffmpeg_kit_flutter_min_gpl/ffprobe_kit.dart'; // Removido temporariamente
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/services.dart';
import 'package:video_thumbnail/video_thumbnail.dart';
import '../models/storie_visto_model.dart';
import '/locale/language.dart';
import '/models/storie_file_model.dart';
import '/models/usuario_model.dart';
import '../utils/debug_logger.dart';
import '../token_usuario.dart';
import '../controllers/stories_gallery_controller.dart';
import '../services/stories_history_service.dart';
import '../utils/context_utils.dart';

class StoriesRepository {
  static final StoriesHistoryService _historyService = StoriesHistoryService();
  
  // M√©todo para testar autentica√ß√£o
  static Future<bool> testAuthentication() async {
    try {
      final user = FirebaseAuth.instance.currentUser;
      debugPrint('üîç TESTE AUTH: Usu√°rio atual: ${user?.email ?? "null"}');
      
      if (user == null) {
        debugPrint('‚ùå TESTE AUTH: Usu√°rio n√£o autenticado');
        return false;
      }
      
      // Testar se o token ainda √© v√°lido
      final token = await user.getIdToken(true);
      debugPrint('‚úÖ TESTE AUTH: Token obtido com sucesso');
      
      // Testar acesso ao Firestore
      await FirebaseFirestore.instance.collection('test').limit(1).get();
      debugPrint('‚úÖ TESTE AUTH: Acesso ao Firestore OK');
      
      return true;
    } catch (e) {
      debugPrint('‚ùå TESTE AUTH: Erro: $e');
      return false;
    }
  }
  
  static void _showProgressDialog(String message) {
    Get.defaultDialog(
      title: 'Salvando Story',
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          const SizedBox(height: 16),
          Text(message, textAlign: TextAlign.center),
        ],
      ),
      barrierDismissible: false
    );
  }

  // M√©todo helper para definir p√∫blico-alvo baseado no contexto
  static String? _getPublicoAlvoByContext(String? contexto) {
    switch (contexto) {
      case 'sinais_isaque':
        return UserSexo.feminino.name;
      case 'sinais_rebeca':
        return UserSexo.masculino.name;
      default:
        return null; // Vis√≠vel para todos
    }
  }

  // M√©todo helper para buscar stories por contexto
  static Stream<List<StorieFileModel>> _getStoriesByContext(String contexto) {
    switch (contexto) {
      case 'sinais_isaque':
        return getAllSinaisIsaque();
      case 'sinais_rebeca':
        return getAllSinaisRebeca();
      default:
        return getAll();
    }
  }
  
  static void _updateProgressDialog(String message) {
    // Fechar dialog atual e abrir novo com mensagem atualizada
    if (Get.isDialogOpen == true) {
      Get.back();
    }
    _showProgressDialog(message);
  }

  static Future<bool> addImg({
    required String link,
    required Uint8List img,
    required String? idioma,
    String? contexto,
    String? titulo,
    String? descricao,
    String? tituloNotificacaoMasculino,
    String? tituloNotificacaoFeminino,
    String? notificacaoMasculino,
    String? notificacaoFeminino,
    bool? enviarNotificacao,
  }) async {

    print('DEBUG REPO: Iniciando addImg');
    print('DEBUG REPO: Contexto: $contexto');
    print('DEBUG REPO: Tamanho da imagem: ${img.length} bytes');

    Get.defaultDialog(
      title: 'Salvando Story',
      content: const Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          CircularProgressIndicator(),
          SizedBox(height: 16),
          Text('Fazendo upload da imagem...'),
        ],
      ),
      barrierDismissible: false
    );

    try {
      // Validar dados da imagem antes do upload
      if (img.isEmpty) {
        throw Exception('Dados da imagem est√£o vazios');
      }
      
      // Upload da imagem
      print('DEBUG REPO: Fazendo upload da imagem');
      String fileUrl = await _uploadImg(img);
      print('DEBUG REPO: Upload conclu√≠do. URL: $fileUrl');
      
      // Verificar se a URL foi obtida corretamente
      if (fileUrl.isEmpty || !fileUrl.startsWith('https://')) {
        throw Exception('URL de upload inv√°lida: $fileUrl');
      }
      
      // Preparar dados do documento - usar contexto fornecido ou principal como padr√£o
      final contextoFinal = contexto ?? 'principal';
      var body = {
        'link': link,
        'fileUrl': fileUrl,
        'videoDuration': 10, // 10 segundos para imagens
        'dataCadastro': Timestamp.now(), // Usar Timestamp em vez de DateTime
        'fileType': StorieFileType.img.name,
        'contexto': contextoFinal,
        'publicoAlvo': null, // Vis√≠vel para todos no contexto principal
        // Novos campos
        'titulo': titulo,
        'descricao': descricao,
        'tituloNotificacaoMasculino': tituloNotificacaoMasculino,
        'tituloNotificacaoFeminino': tituloNotificacaoFeminino,
        'notificacaoMasculino': notificacaoMasculino,
        'notificacaoFeminino': notificacaoFeminino,
        'enviarNotificacao': enviarNotificacao ?? false,
      };
      
      if(idioma != null && idioma.isNotEmpty) {
        body['idioma'] = idioma;
      }
      
      print('DEBUG REPO: Dados preparados: $body');
      
      // Selecionar cole√ß√£o baseada no contexto
      String colecao;
      switch (contextoFinal) {
        case 'sinais_isaque':
          colecao = 'stories_sinais_isaque';
          break;
        case 'sinais_rebeca':
          colecao = 'stories_sinais_rebeca';
          break;
        case 'nosso_proposito':
          colecao = 'stories_nosso_proposito';
          break;
        default:
          colecao = 'stories_files';
          break;
      }
      print('DEBUG REPO: Salvando na cole√ß√£o: $colecao (contexto: $contextoFinal)');
      
      DocumentReference docRef = await FirebaseFirestore.instance.collection(colecao).add(body);
      print('DEBUG REPO: Documento salvo com ID: ${docRef.id}');

      // Verificar se foi realmente salvo
      DocumentSnapshot verifyDoc = await docRef.get();
      if (!verifyDoc.exists) {
        throw Exception('Documento n√£o foi criado corretamente');
      }
      print('DEBUG REPO: Verifica√ß√£o passou - documento existe');

      Get.back();
      print('DEBUG REPO: addImg conclu√≠do com sucesso');
      
      return true;
      
    } catch (e, stackTrace) {
      print('DEBUG REPO: Erro em addImg: $e');
      print('DEBUG REPO: Stack trace: $stackTrace');
      Get.back();
      
      // Mostrar erro amig√°vel para o usu√°rio
      String errorMessage = _getFirebaseErrorMessage(e.toString());
      Get.rawSnackbar(
        title: 'Erro ao salvar story',
        message: errorMessage,
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 5),
        snackPosition: SnackPosition.TOP,
      );
      
      rethrow;
    }
  }
  
  /// Converte erros do Firebase em mensagens amig√°veis
  static String _getFirebaseErrorMessage(String error) {
    final errorLower = error.toLowerCase();
    
    if (errorLower.contains('unauthorized') || errorLower.contains('permission')) {
      return '‚ùå Sem permiss√£o para salvar. Verifique se voc√™ est√° logado.';
    } else if (errorLower.contains('network') || errorLower.contains('connection')) {
      return '‚ùå Erro de conex√£o. Verifique sua internet e tente novamente.';
    } else if (errorLower.contains('timeout')) {
      return '‚ùå Upload demorou muito. Tente novamente com uma conex√£o melhor.';
    } else if (errorLower.contains('quota') || errorLower.contains('storage') || errorLower.contains('limite')) {
      return '‚ùå Limite de armazenamento atingido. Contate o administrador.';
    } else if (errorLower.contains('invalid') || errorLower.contains('format')) {
      return '‚ùå Formato de arquivo inv√°lido. Use PNG, JPG ou JPEG.';
    } else if (errorLower.contains('too large') || errorLower.contains('size') || errorLower.contains('grande')) {
      return '‚ùå Arquivo muito grande. Reduza o tamanho e tente novamente.';
    } else if (errorLower.contains('firebase') || errorLower.contains('unknown')) {
      return '‚ùå Erro no servidor. Tente novamente em alguns minutos.';
    } else if (errorLower.contains('retry') || errorLower.contains('tentativas')) {
      return '‚ùå Muitas tentativas. Aguarde alguns minutos e tente novamente.';
    } else {
      return '‚ùå Erro inesperado ao salvar story. Tente novamente.';
    }
  }
  
  static void _validateAddImgParameters(String link, Uint8List img, String? idioma, String? contexto) {
    if (img.isEmpty) {
      throw ArgumentError('Image data cannot be empty');
    }
    
    if (contexto != null && !['principal', 'sinais_isaque'].contains(contexto)) {
      throw ArgumentError('Invalid context: $contexto');
    }
    
    if (idioma != null && idioma.trim().isEmpty) {
      throw ArgumentError('Language cannot be empty string');
    }
  }
  
  static Map<String, dynamic> _prepareDocumentData(String link, String fileUrl, String? idioma, String contextoFinal) {
    var body = {
      'link': link,
      'fileUrl': fileUrl,
      'videoDuration': '0',
      'dataCadastro': Timestamp.now(), // Usar Timestamp em vez de DateTime
      'fileType': StorieFileType.img.name,
      'contexto': contextoFinal,
      'publicoAlvo': _getPublicoAlvoByContext(contextoFinal),
    };
    
    if(idioma != null && idioma.isNotEmpty) {
      body['idioma'] = idioma;
    }
    
    return body;
  }
  
  static Future<String> _uploadImgWithRetry(Uint8List img, {int maxRetries = 3}) async {
    int attempts = 0;
    Exception? lastException;
    
    while (attempts < maxRetries) {
      try {
        attempts++;
        DebugLogger.debug('StoriesRepository', 'upload_attempt', {
          'attempt': attempts,
          'maxRetries': maxRetries
        });
        
        return await _uploadImg(img);
        
      } catch (e) {
        lastException = e is Exception ? e : Exception(e.toString());
        DebugLogger.error('StoriesRepository', 'upload_attempt_failed', e.toString(), {
          'attempt': attempts,
          'maxRetries': maxRetries
        });
        
        if (attempts < maxRetries) {
          // Aguardar antes de tentar novamente (exponential backoff)
          int delaySeconds = attempts * 2;
          DebugLogger.debug('StoriesRepository', 'retry_delay', {
            'delaySeconds': delaySeconds
          });
          await Future.delayed(Duration(seconds: delaySeconds));
        }
      }
    }
    
    throw lastException ?? Exception('Upload failed after $maxRetries attempts');
  }
  
  static Future<DocumentReference> _saveDocumentWithRetry(String collection, Map<String, dynamic> data, {int maxRetries = 3}) async {
    int attempts = 0;
    Exception? lastException;
    
    while (attempts < maxRetries) {
      try {
        attempts++;
        DebugLogger.debug('StoriesRepository', 'firestore_save_attempt', {
          'attempt': attempts,
          'maxRetries': maxRetries,
          'collection': collection
        });
        
        return await FirebaseFirestore.instance.collection(collection).add(data);
        
      } catch (e) {
        lastException = e is Exception ? e : Exception(e.toString());
        DebugLogger.error('StoriesRepository', 'firestore_save_attempt_failed', e.toString(), {
          'attempt': attempts,
          'maxRetries': maxRetries,
          'collection': collection
        });
        
        if (attempts < maxRetries) {
          // Aguardar antes de tentar novamente
          int delaySeconds = attempts;
          await Future.delayed(Duration(seconds: delaySeconds));
        }
      }
    }
    
    throw lastException ?? Exception('Firestore save failed after $maxRetries attempts');
  }
  
  static Future<void> _verifyDocumentCreation(DocumentReference docRef) async {
    try {
      DocumentSnapshot verifyDoc = await docRef.get();
      if (!verifyDoc.exists) {
        throw Exception('Document verification failed: document does not exist');
      }
      
      // Verificar se os dados est√£o corretos
      Map<String, dynamic>? data = verifyDoc.data() as Map<String, dynamic>?;
      if (data == null || data.isEmpty) {
        throw Exception('Document verification failed: document has no data');
      }
      
      // Verificar campos obrigat√≥rios
      List<String> requiredFields = ['fileUrl', 'dataCadastro', 'fileType', 'contexto'];
      for (String field in requiredFields) {
        if (!data.containsKey(field) || data[field] == null) {
          throw Exception('Document verification failed: missing required field $field');
        }
      }
      
    } catch (e) {
      DebugLogger.error('StoriesRepository', 'document_verification_error', e.toString(), {
        'documentId': docRef.id
      });
      rethrow;
    }
  }
  
  static Future<void> _rollbackOnError(String? uploadedFileUrl, DocumentReference? createdDoc) async {
    DebugLogger.debug('StoriesRepository', 'rollback_start', {
      'hasUploadedFile': uploadedFileUrl != null,
      'hasCreatedDoc': createdDoc != null
    });
    
    try {
      // Tentar deletar documento criado
      if (createdDoc != null) {
        await createdDoc.delete();
        DebugLogger.debug('StoriesRepository', 'rollback_document_deleted', {
          'documentId': createdDoc.id
        });
      }
      
      // Tentar deletar arquivo do Storage
      if (uploadedFileUrl != null) {
        try {
          Reference ref = FirebaseStorage.instance.refFromURL(uploadedFileUrl);
          await ref.delete();
          DebugLogger.debug('StoriesRepository', 'rollback_file_deleted', {
            'fileUrl': uploadedFileUrl
          });
        } catch (e) {
          DebugLogger.error('StoriesRepository', 'rollback_file_delete_failed', e.toString());
          // N√£o relan√ßar erro de rollback de arquivo
        }
      }
      
    } catch (e) {
      DebugLogger.error('StoriesRepository', 'rollback_error', e.toString());
      // N√£o relan√ßar erros de rollback
    }
  }

  static Future<bool> addVideo({
    required String link,
    required File video,
    required String? idioma,
    String? contexto,
    String? titulo,
    String? descricao,
    String? tituloNotificacaoMasculino,
    String? tituloNotificacaoFeminino,
    String? notificacaoMasculino,
    String? notificacaoFeminino,
    bool? enviarNotificacao,
  }) async {

    Get.defaultDialog(
      title: AppLanguage.lang('validando'),
      content: const CircularProgressIndicator(),
      barrierDismissible: false
    ); 

    // Valida√ß√£o simplificada do v√≠deo usando video_thumbnail
    try {
      final thumbnail = await VideoThumbnail.thumbnailData(
        video: video.path,
        imageFormat: ImageFormat.JPEG,
        maxWidth: 128,
        quality: 25,
      );
      
      if (thumbnail == null) {
        Get.back();
        Get.rawSnackbar(message: AppLanguage.lang('falha_ao_validar_video'));
        return false;
      }
    } catch (e) {
      Get.back();
      Get.rawSnackbar(message: AppLanguage.lang('falha_ao_validar_video'));
      return false;
    }


    Uint8List? thumbnail = await VideoThumbnail.thumbnailData(
      video: video.path,
      imageFormat: ImageFormat.JPEG,
      maxWidth: 480,
      quality: 25,
    );

    if(thumbnail == null) {
      Get.rawSnackbar(message: AppLanguage.lang('falha_ao_validar_video'));
      return false;
    }

    String thumbnailImg = await _uploadImg(thumbnail);

    String fileUrl = await _uploadVideo(video);

    var body = {
      'link': link,
      'fileUrl': fileUrl,
      'videoThumbnail': thumbnailImg,
      'dataCadastro': Timestamp.now(), // Usar Timestamp em vez de DateTime
      'videoDuration': 0, // V√≠deos mant√™m dura√ß√£o original (sem limites)
      'fileType': StorieFileType.video.name,
      'contexto': 'principal', // Sempre salvar no contexto principal
      'publicoAlvo': null, // Vis√≠vel para todos no contexto principal
      // Novos campos
      'titulo': titulo,
      'descricao': descricao,
      'tituloNotificacaoMasculino': tituloNotificacaoMasculino,
      'tituloNotificacaoFeminino': tituloNotificacaoFeminino,
      'notificacaoMasculino': notificacaoMasculino,
      'notificacaoFeminino': notificacaoFeminino,
      'enviarNotificacao': enviarNotificacao ?? false,
    };

    if(idioma != null && idioma.isNotEmpty) {
      body['idioma'] = idioma;
    }

    // Escolhe a cole√ß√£o baseada no contexto
    String colecao;
    switch (contexto) {
      case 'sinais_isaque':
        colecao = 'stories_sinais_isaque';
        break;
      case 'sinais_rebeca':
        colecao = 'stories_sinais_rebeca';
        break;
      case 'nosso_proposito':
        colecao = 'stories_nosso_proposito';
        break;
      default:
        colecao = 'stories_files';
    }
    try {
      await FirebaseFirestore.instance.collection(colecao).add(body);
      Get.back();
      return true;
    } catch (e) {
      print('DEBUG REPO: Erro ao salvar v√≠deo no Firestore: $e');
      Get.back();
      
      // Mostrar erro amig√°vel para o usu√°rio
      String errorMessage = _getFirebaseErrorMessage(e.toString());
      Get.rawSnackbar(
        title: 'Erro ao salvar v√≠deo',
        message: errorMessage,
        backgroundColor: Colors.red,
        duration: const Duration(seconds: 5),
        snackPosition: SnackPosition.TOP,
      );
      
      return false;
    }
  }

  static Stream<List<StorieFileModel>> getAll() {
    const String expectedContext = 'principal';
    const String collectionName = 'stories_files';
    
    // Validar contexto antes de prosseguir
    if (!ContextValidator.isValidContext(expectedContext)) {
      ContextDebug.logCriticalError('getAll', 'Contexto inv√°lido', expectedContext);
      return Stream.value([]);
    }
    
    // Validar se a cole√ß√£o corresponde ao contexto
    if (!ContextValidator.validateContextForCollection(expectedContext, collectionName)) {
      ContextDebug.logCriticalError('getAll', 'Cole√ß√£o n√£o corresponde ao contexto', expectedContext);
      return Stream.value([]);
    }
    
    ContextDebug.logSummary('getAll', expectedContext, {
      'collection': collectionName,
      'operation': 'LOAD_PRINCIPAL_STORIES'
    });
    
    // Mover stories expirados para o hist√≥rico (executa em background)
    _historyService.moveExpiredStoriesToHistory().catchError((e) {
      print('‚ö†Ô∏è REPO: Erro ao mover stories expirados: $e');
    });
    
    return ContextDebug.measurePerformance('getAll_query', expectedContext, () {
      return FirebaseFirestore.instance
          .collection(collectionName)
          .where('contexto', isEqualTo: expectedContext) // FILTRO EXPL√çCITO POR CONTEXTO PRINCIPAL
          .snapshots();
    }).asyncMap((event) async {
      ContextDebug.logLoad(expectedContext, collectionName, event.docs.length, 'getAll');
      
      // Processar documentos
      final stories = event.docs.map((e) {
        final data = e.data();
        ContextDebug.logSummary('processing_document', expectedContext, {
          'documentId': e.id,
          'documentContext': data['contexto'] ?? 'null'
        });
        
        StorieFileModel story = StorieFileModel.fromJson(data);
        story.id = e.id;
        return story;
      }).toList();
      
      // VALIDA√á√ÉO ADICIONAL: Filtrar stories que n√£o pertencem ao contexto principal
      final validStories = StoryContextFilter.filterByContext(stories, expectedContext);
      
      // Detectar vazamentos de contexto
      final hasLeaks = StoryContextFilter.detectContextLeaks(stories, expectedContext);
      if (hasLeaks) {
        ContextDebug.logCriticalError('getAll', 'VAZAMENTO DE CONTEXTO DETECTADO - Stories de outros contextos na cole√ß√£o principal', expectedContext);
      }
      
      ContextDebug.logFilter(expectedContext, stories.length, validStories.length, 'getAll');
      
      return validStories;
    });
  }

  // Nova fun√ß√£o para buscar stories do contexto "Sinais de Meu Isaque"
  static Stream<List<StorieFileModel>> getAllSinaisIsaque() {
    const String expectedContext = 'sinais_isaque';
    const String collectionName = 'stories_sinais_isaque';
    
    // Validar contexto antes de prosseguir
    if (!ContextValidator.isValidContext(expectedContext)) {
      ContextDebug.logCriticalError('getAllSinaisIsaque', 'Contexto inv√°lido', expectedContext);
      return Stream.value([]);
    }
    
    // Validar se a cole√ß√£o corresponde ao contexto
    if (!ContextValidator.validateContextForCollection(expectedContext, collectionName)) {
      ContextDebug.logCriticalError('getAllSinaisIsaque', 'Cole√ß√£o n√£o corresponde ao contexto', expectedContext);
      return Stream.value([]);
    }
    
    ContextDebug.logSummary('getAllSinaisIsaque', expectedContext, {
      'collection': collectionName,
      'operation': 'LOAD_STORIES_BY_CONTEXT'
    });
    
    // Mover stories expirados para o hist√≥rico (executa em background)
    _historyService.moveExpiredStoriesToHistory().catchError((e) {
      print('‚ö†Ô∏è REPO: Erro ao mover stories expirados: $e');
    });
    
    return ContextDebug.measurePerformance('getAllSinaisIsaque_query', expectedContext, () {
      return FirebaseFirestore.instance
          .collection(collectionName)
          .where('contexto', isEqualTo: expectedContext) // FILTRO EXPL√çCITO POR CONTEXTO
          .snapshots();
    }).asyncMap((event) async {
      ContextDebug.logLoad(expectedContext, collectionName, event.docs.length, 'getAllSinaisIsaque');
      
      // Processar documentos
      final stories = event.docs.map((e) {
        final data = e.data();
        ContextDebug.logSummary('processing_document', expectedContext, {
          'documentId': e.id,
          'documentContext': data['contexto'] ?? 'null'
        });
        
        StorieFileModel story = StorieFileModel.fromJson(data);
        story.id = e.id;
        return story;
      }).toList();
      
      // VALIDA√á√ÉO ADICIONAL: Filtrar stories que n√£o pertencem ao contexto esperado
      final validStories = StoryContextFilter.filterByContext(stories, expectedContext);
      
      // Detectar vazamentos de contexto
      final hasLeaks = StoryContextFilter.detectContextLeaks(stories, expectedContext);
      if (hasLeaks) {
        ContextDebug.logCriticalError('getAllSinaisIsaque', 'VAZAMENTO DE CONTEXTO DETECTADO', expectedContext);
      }
      
      ContextDebug.logFilter(expectedContext, stories.length, validStories.length, 'getAllSinaisIsaque');
      
      return validStories;
    });
  }

  // Nova fun√ß√£o para buscar stories do contexto "Sinais de Minha Rebeca"
  static Stream<List<StorieFileModel>> getAllSinaisRebeca() {
    const String expectedContext = 'sinais_rebeca';
    const String collectionName = 'stories_sinais_rebeca';
    
    // Validar contexto antes de prosseguir
    if (!ContextValidator.isValidContext(expectedContext)) {
      ContextDebug.logCriticalError('getAllSinaisRebeca', 'Contexto inv√°lido', expectedContext);
      return Stream.value([]);
    }
    
    // Validar se a cole√ß√£o corresponde ao contexto
    if (!ContextValidator.validateContextForCollection(expectedContext, collectionName)) {
      ContextDebug.logCriticalError('getAllSinaisRebeca', 'Cole√ß√£o n√£o corresponde ao contexto', expectedContext);
      return Stream.value([]);
    }
    
    ContextDebug.logSummary('getAllSinaisRebeca', expectedContext, {
      'collection': collectionName,
      'operation': 'LOAD_STORIES_BY_CONTEXT'
    });
    
    // Mover stories expirados para o hist√≥rico (executa em background)
    _historyService.moveExpiredStoriesToHistory().catchError((e) {
      print('‚ö†Ô∏è REPO: Erro ao mover stories expirados: $e');
    });
    
    return ContextDebug.measurePerformance('getAllSinaisRebeca_query', expectedContext, () {
      return FirebaseFirestore.instance
          .collection(collectionName)
          .where('contexto', isEqualTo: expectedContext) // FILTRO EXPL√çCITO POR CONTEXTO
          .snapshots();
    }).asyncMap((event) async {
      ContextDebug.logLoad(expectedContext, collectionName, event.docs.length, 'getAllSinaisRebeca');
      
      // Processar documentos
      final stories = event.docs.map((e) {
        final data = e.data();
        ContextDebug.logSummary('processing_document', expectedContext, {
          'documentId': e.id,
          'documentContext': data['contexto'] ?? 'null'
        });
        
        StorieFileModel story = StorieFileModel.fromJson(data);
        story.id = e.id;
        return story;
      }).toList();
      
      // VALIDA√á√ÉO ADICIONAL: Filtrar stories que n√£o pertencem ao contexto esperado
      final validStories = StoryContextFilter.filterByContext(stories, expectedContext);
      
      // Detectar vazamentos de contexto
      final hasLeaks = StoryContextFilter.detectContextLeaks(stories, expectedContext);
      if (hasLeaks) {
        ContextDebug.logCriticalError('getAllSinaisRebeca', 'VAZAMENTO DE CONTEXTO DETECTADO', expectedContext);
      }
      
      ContextDebug.logFilter(expectedContext, stories.length, validStories.length, 'getAllSinaisRebeca');
      
      return validStories;
    });
  }

  // Fun√ß√£o para buscar stories por contexto
  static Stream<List<StorieFileModel>> getAllByContext(String contexto) {
    String colecao;
    switch (contexto) {
      case 'sinais_isaque':
        colecao = 'stories_sinais_isaque';
        break;
      case 'sinais_rebeca':
        colecao = 'stories_sinais_rebeca';
        break;
      case 'nosso_proposito':
        colecao = 'stories_nosso_proposito';
        break;
      default:
        colecao = 'stories_files';
    }
    
    print('DEBUG REPO: ===== CARREGANDO STORIES POR CONTEXTO =====');
    print('DEBUG REPO: Contexto solicitado: "$contexto"');
    print('DEBUG REPO: Cole√ß√£o selecionada: "$colecao"');
    
    return FirebaseFirestore.instance.collection(colecao).snapshots().map((event) {
      print('DEBUG REPO: ===== RESULTADO DA CONSULTA =====');
      print('DEBUG REPO: Recebidos ${event.docs.length} documentos da cole√ß√£o $colecao');
      
      if (event.docs.isEmpty) {
        print('DEBUG REPO: ‚ö†Ô∏è  NENHUM DOCUMENTO ENCONTRADO na cole√ß√£o $colecao');
      }
      
      return event.docs.map((e) {
        print('DEBUG REPO: üìÑ Processando documento ${e.id}');
        print('DEBUG REPO: üìÑ Dados: ${e.data()}');
        try {
          StorieFileModel story = StorieFileModel.fromJson(e.data());
          story.id = e.id;
          print('DEBUG REPO: ‚úÖ Story processado com sucesso: ${story.id}');
          return story;
        } catch (error) {
          print('DEBUG REPO: ‚ùå Erro ao processar documento ${e.id}: $error');
          rethrow;
        }
      }).toList();
    });
  }

  static Stream<List<StorieFileModel>> getAllAntigos() {
    return FirebaseFirestore.instance.collection('stories_antigos').snapshots().map((event) => event.docs.map((e) {
      StorieFileModel story = StorieFileModel.fromJson(e.data());
      story.id = e.id;
      return story;
    }).toList());
  }



  static Stream<List<StorieVistoModel>> getStoreVisto() {
    return FirebaseFirestore.instance.collection('stores_visto').where('idUser', isEqualTo: FirebaseAuth.instance.currentUser!.uid).snapshots().map((event) => event.docs.map((e) {
      StorieVistoModel chat = StorieVistoModel.fromJson(e.data());
      chat.id = e.id;
      return chat;
    }).toList());
  }

  // Novo m√©todo para verificar stories vistos por contexto
  static Stream<List<StorieVistoModel>> getStoreVistoByContext(String contexto) {
    return FirebaseFirestore.instance.collection('stores_visto')
        .where('idUser', isEqualTo: FirebaseAuth.instance.currentUser!.uid)
        .where('contexto', isEqualTo: contexto)
        .snapshots().map((event) => event.docs.map((e) {
      StorieVistoModel chat = StorieVistoModel.fromJson(e.data());
      chat.id = e.id;
      return chat;
    }).toList());
  }

  // M√©todo para verificar se todos os stories de um contexto foram vistos
  static Future<bool> allStoriesViewedInContext(String contexto, UserSexo? userSexo) async {
    try {
      // Validar e normalizar contexto
      final normalizedContext = ContextValidator.normalizeContext(contexto);
      if (!ContextValidator.validateAndLog(contexto, 'allStoriesViewedInContext')) {
        ContextDebug.logCriticalError('allStoriesViewedInContext', 'Contexto inv√°lido, usando contexto normalizado', normalizedContext);
      }
      
      ContextDebug.logSummary('allStoriesViewedInContext', normalizedContext, {
        'originalContext': contexto,
        'normalizedContext': normalizedContext,
        'userSexo': userSexo?.name,
        'operation': 'CHECK_ALL_STORIES_VIEWED'
      });
      
      // Buscar todos os stories v√°lidos do contexto NORMALIZADO
      final allStories = await _getStoriesByContext(normalizedContext).first;
      
      // VALIDA√á√ÉO ADICIONAL: Filtrar stories que n√£o pertencem ao contexto esperado
      final contextFilteredStories = StoryContextFilter.filterByContext(allStories, normalizedContext);
      
      // Detectar vazamentos de contexto
      final hasLeaks = StoryContextFilter.detectContextLeaks(allStories, normalizedContext);
      if (hasLeaks) {
        ContextDebug.logCriticalError('allStoriesViewedInContext', 'VAZAMENTO DE CONTEXTO DETECTADO ao verificar stories vistos', normalizedContext);
      }
      
      ContextDebug.logFilter(normalizedContext, allStories.length, contextFilteredStories.length, 'allStoriesViewedInContext_contextFilter');
      
      // Filtrar stories v√°lidos (24h, idioma e p√∫blico-alvo)
      final now = DateTime.now();
      final twentyFourHoursAgo = now.subtract(const Duration(hours: 24));
      
      final validStories = contextFilteredStories.where((story) {
        // Verificar se est√° dentro de 24h
        final storyDate = story.dataCadastro?.toDate();
        if (storyDate == null || storyDate.isBefore(twentyFourHoursAgo)) {
          return false;
        }
        
        // Verificar idioma
        if (story.idioma != null && story.idioma != TokenUsuario().idioma) {
          return false;
        }
        
        // Verificar p√∫blico-alvo
        if (story.publicoAlvo != null && story.publicoAlvo != userSexo) {
          return false;
        }
        
        // VALIDA√á√ÉO ADICIONAL: Verificar se o story realmente pertence ao contexto
        if (!StoryContextFilter.validateStoryContext(story, normalizedContext, debugEnabled: false)) {
          ContextDebug.logCriticalError('allStoriesViewedInContext', 'Story ${story.id} n√£o pertence ao contexto $normalizedContext', normalizedContext);
          return false;
        }
        
        return true;
      }).toList();

      ContextDebug.logSummary('allStoriesViewedInContext_validStories', normalizedContext, {
        'totalStories': allStories.length,
        'contextFilteredStories': contextFilteredStories.length,
        'validStories': validStories.length,
        'hasLeaks': hasLeaks
      });

      if (validStories.isEmpty) {
        ContextDebug.logSummary('allStoriesViewedInContext_noValidStories', normalizedContext, {
          'result': 'ALL_VIEWED_NO_STORIES'
        });
        return true; // Se n√£o h√° stories v√°lidos, considera como "todos vistos"
      }

      // Buscar stories vistos do contexto NORMALIZADO
      final storiesVistos = await getStoreVistoByContext(normalizedContext).first;
      final storiesVistosIds = storiesVistos.map((v) => v.idStore).toSet();

      // Verificar se todos os stories v√°lidos foram vistos
      final allViewed = validStories.every((story) => storiesVistosIds.contains(story.id));
      
      ContextDebug.logSummary('allStoriesViewedInContext_result', normalizedContext, {
        'validStories': validStories.length,
        'viewedStories': storiesVistosIds.length,
        'allViewed': allViewed,
        'unviewedCount': validStories.length - storiesVistosIds.length
      });
      
      return allViewed;
    } catch (e) {
      ContextDebug.logCriticalError('allStoriesViewedInContext', 'Erro ao verificar stories vistos: $e', contexto);
      return false;
    }
  }
  
  /// M√©todo para verificar se h√° stories n√£o vistos (para o c√≠rculo verde)
  static Future<bool> hasUnviewedStories(String contexto, UserSexo? userSexo) async {
    try {
      // Validar e normalizar contexto
      final normalizedContext = ContextValidator.normalizeContext(contexto);
      if (!ContextValidator.validateAndLog(contexto, 'hasUnviewedStories')) {
        ContextDebug.logCriticalError('hasUnviewedStories', 'Contexto inv√°lido, usando contexto normalizado', normalizedContext);
      }
      
      ContextDebug.logSummary('hasUnviewedStories', normalizedContext, {
        'originalContext': contexto,
        'normalizedContext': normalizedContext,
        'userSexo': userSexo?.name,
        'operation': 'CHECK_UNVIEWED_STORIES'
      });
      
      final allViewed = await allStoriesViewedInContext(normalizedContext, userSexo); // USAR CONTEXTO NORMALIZADO
      final hasUnviewed = !allViewed;
      
      ContextDebug.logSummary('hasUnviewedStories_result', normalizedContext, {
        'allViewed': allViewed,
        'hasUnviewed': hasUnviewed
      });
      
      return hasUnviewed; // Retorna true se h√° stories n√£o vistos
    } catch (e) {
      ContextDebug.logCriticalError('hasUnviewedStories', 'Erro ao verificar stories n√£o vistos: $e', contexto);
      return false;
    }
  }

  static Future<void> addVisto(String id, {String? contexto}) async {
    try {
      final userId = FirebaseAuth.instance.currentUser?.uid;
      if (userId == null) {
        ContextDebug.logCriticalError('addVisto', 'Usu√°rio n√£o autenticado', contexto ?? 'principal');
        return;
      }
      
      // Validar e normalizar contexto
      final normalizedContext = ContextValidator.normalizeContext(contexto);
      if (!ContextValidator.validateAndLog(contexto, 'addVisto')) {
        ContextDebug.logCriticalError('addVisto', 'Contexto inv√°lido, usando contexto normalizado', normalizedContext);
      }
      
      // Validar par√¢metros
      if (id.isEmpty) {
        ContextDebug.logCriticalError('addVisto', 'Story ID vazio', normalizedContext);
        return;
      }
      
      ContextDebug.logSummary('addVisto', normalizedContext, {
        'storyId': id,
        'userId': userId,
        'originalContext': contexto,
        'normalizedContext': normalizedContext,
        'operation': 'MARK_STORY_AS_VIEWED'
      });
      
      final query = await FirebaseFirestore.instance.collection('stores_visto')
          .where('idUser', isEqualTo: userId)
          .where('idStore', isEqualTo: id)
          .get();
      
      if(query.docs.isEmpty) {
        await FirebaseFirestore.instance.collection('stores_visto').add({
          'data': Timestamp.now(), // Usar Timestamp em vez de DateTime
          'idStore': id,
          'idUser': userId,
          'contexto': normalizedContext, // USAR CONTEXTO NORMALIZADO
        });
        
        ContextDebug.logSummary('addVisto_success', normalizedContext, {
          'storyId': id,
          'markedAsViewed': true
        });
      } else {
        // Verificar se o contexto do registro existente est√° correto
        final existingDoc = query.docs.first;
        final existingData = existingDoc.data() as Map<String, dynamic>;
        final existingContext = ContextValidator.normalizeContext(existingData['contexto'] as String?);
        
        if (existingContext != normalizedContext) {
          ContextDebug.logCriticalError('addVisto', 
            'VAZAMENTO DETECTADO - Registro existente tem contexto "$existingContext" mas deveria ser "$normalizedContext"', 
            normalizedContext);
        }
        
        ContextDebug.logSummary('addVisto_already_viewed', normalizedContext, {
          'storyId': id,
          'alreadyViewed': true,
          'existingContext': existingContext
        });
      }
    } catch (e) {
      ContextDebug.logCriticalError('addVisto', 'Erro ao marcar story como visto: $e', contexto ?? 'principal');
    }
  }

  static Future<List<StorieFileModel>> getAllFuture() async {
    List<StorieFileModel> all = [];
    final query = await FirebaseFirestore.instance.collection('stories_files').get();
    
    for (var e in query.docs) {
      StorieFileModel item = StorieFileModel.fromJson(e.data());
      item.id = e.id;
      all.add(item);
    }

    return all;
  }
  
  /// Busca um story espec√≠fico por ID
  /// Busca um story espec√≠fico por ID em todas as cole√ß√µes
  static Future<StorieFileModel?> getStoryById(String storyId) async {
    try {
      print('üîç STORIES: Buscando story com ID: $storyId');
      
      // Lista de cole√ß√µes onde os stories podem estar
      final collections = [
        'stories_files', 
        'stories_sinais_rebeca',
        'stories_sinais_isaque',
        'stories_nosso_proposito',
        'stories',
      ];
      
      // Busca em cada cole√ß√£o
      for (final collection in collections) {
        try {
          print('üîç STORIES: Verificando cole√ß√£o: $collection');
          final doc = await FirebaseFirestore.instance
              .collection(collection)
              .doc(storyId)
              .get();
          
          if (doc.exists) {
            print('‚úÖ STORIES: Story encontrado na cole√ß√£o: $collection');
            StorieFileModel story = StorieFileModel.fromJson(doc.data()!);
            story.id = doc.id;
            return story;
          }
        } catch (e) {
          print('‚ö†Ô∏è STORIES: Erro ao buscar na cole√ß√£o $collection: $e');
          continue;
        }
      }
      
      print('‚ùå STORIES: Story n√£o encontrado em nenhuma cole√ß√£o');
      return null;
    } catch (e) {
      print('‚ùå STORIES: Erro geral ao buscar story por ID: $e');
      return null;
    }
  }
  
  /// Obt√©m stories por contexto (vers√£o Future para uso na nova interface)
  static Future<List<StorieFileModel>> getStoriesByContexto(String contexto, UserSexo? userSexo) async {
    try {
      // Executar migra√ß√£o de hist√≥rico em background (n√£o bloquear carregamento)
      _historyService.moveExpiredStoriesToHistory().catchError((e) {
        print('DEBUG REPO: Erro na migra√ß√£o de hist√≥rico: $e');
      });
      
      String colecao;
      switch (contexto) {
        case 'sinais_isaque':
          colecao = 'stories_sinais_isaque';
          break;
        case 'sinais_rebeca':
          colecao = 'stories_sinais_rebeca';
          break;
        case 'nosso_proposito':
          colecao = 'stories_nosso_proposito';
          break;
        default:
          colecao = 'stories_files';
      }
      
      print('DEBUG REPO: Carregando stories da cole√ß√£o $colecao');
      
      Query query = FirebaseFirestore.instance.collection(colecao);
      
      // Filtrar por p√∫blico-alvo se especificado
      // N√£o usar whereIn com null - Firebase n√£o permite
      // Vamos filtrar no c√≥digo depois da consulta
      
      // Ordenar por data de cadastro para garantir ordem consistente
      query = query.orderBy('dataCadastro', descending: false);
      
      final snapshot = await query.get();
      
      List<StorieFileModel> stories = [];
      for (var doc in snapshot.docs) {
        try {
          StorieFileModel story = StorieFileModel.fromJson(doc.data() as Map<String, dynamic>);
          story.id = doc.id;
          
          // Filtrar por idioma se necess√°rio
          if (story.idioma == null || story.idioma == TokenUsuario().idioma) {
            // Filtrar por p√∫blico-alvo (feito aqui para evitar problema com whereIn + null)
            bool publicoAlvoValido = true;
            if (userSexo != null) {
              // Se userSexo √© especificado, aceitar apenas stories sem p√∫blico-alvo ou com p√∫blico-alvo correspondente
              publicoAlvoValido = (story.publicoAlvo == null || story.publicoAlvo == userSexo);
            }
            
            if (publicoAlvoValido) {
              // Verificar se a m√≠dia ainda est√° acess√≠vel
              if (await _isMediaAccessible(story)) {
                stories.add(story);
              } else {
                print('DEBUG REPO: M√≠dia inacess√≠vel para story ${story.id}');
              }
            }
          }
        } catch (e) {
          print('DEBUG REPO: Erro ao processar documento ${doc.id}: $e');
        }
      }
      
      print('DEBUG REPO: Carregados ${stories.length} stories v√°lidos com m√≠dia acess√≠vel');
      return stories;
    } catch (e) {
      print('DEBUG REPO: Erro ao carregar stories por contexto: $e');
      return [];
    }
  }
  
  /// Verifica se a m√≠dia do story ainda est√° acess√≠vel
  static Future<bool> _isMediaAccessible(StorieFileModel story) async {
    try {
      if (story.fileUrl == null || story.fileUrl!.isEmpty) {
        return false;
      }
      
      // Para Firebase Storage, verificar se a URL ainda √© v√°lida
      if (story.fileUrl!.contains('firebasestorage.googleapis.com')) {
        try {
          // Tentar obter metadados do arquivo
          Reference ref = FirebaseStorage.instance.refFromURL(story.fileUrl!);
          await ref.getMetadata();
          return true;
        } catch (e) {
          print('DEBUG REPO: M√≠dia n√£o acess√≠vel: ${story.fileUrl} - $e');
          return false;
        }
      }
      
      // Para outras URLs, assumir que est√£o acess√≠veis
      return true;
    } catch (e) {
      print('DEBUG REPO: Erro ao verificar acessibilidade da m√≠dia: $e');
      return false;
    }
  }

  static Future<String> _uploadImg(Uint8List fileData) async {
    debugPrint('DEBUG REPO: Iniciando upload para Firebase Storage');
    debugPrint('DEBUG REPO: Tamanho: ${fileData.length} bytes');

    try {
      // Verificar se o usu√°rio est√° autenticado
      final user = FirebaseAuth.instance.currentUser;
      debugPrint('DEBUG REPO: Usu√°rio atual: ${user?.email ?? "null"}');
      debugPrint('DEBUG REPO: UID: ${user?.uid ?? "null"}');
      debugPrint('DEBUG REPO: Est√° autenticado: ${user != null}');
      
      if (user == null) {
        // Tentar reautenticar
        debugPrint('DEBUG REPO: Tentando reautenticar...');
        await FirebaseAuth.instance.authStateChanges().first;
        final userAfterWait = FirebaseAuth.instance.currentUser;
        
        if (userAfterWait == null) {
          throw Exception('Usu√°rio n√£o autenticado. Fa√ßa login novamente.');
        }
        
        debugPrint('DEBUG REPO: Reautentica√ß√£o bem-sucedida: ${userAfterWait.email}');
      }
      
      // Validar dados do arquivo
      if (fileData.isEmpty) {
        throw Exception('Dados do arquivo est√£o vazios');
      }
      
      if (fileData.length > 50 * 1024 * 1024) { // 50MB max
        throw Exception('Arquivo muito grande (m√°ximo 50MB)');
      }
      
      // Gerar nome √∫nico para o arquivo
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final userId = user?.uid ?? FirebaseAuth.instance.currentUser?.uid;
      
      if (userId == null) {
        throw Exception('UID do usu√°rio n√£o dispon√≠vel');
      }
      
      final fileName = 'stories_files/${userId}_${timestamp}.png';
      
      debugPrint('DEBUG REPO: Nome do arquivo: $fileName');
      
      // Criar refer√™ncia do Firebase Storage
      Reference ref = FirebaseStorage.instance.ref().child(fileName);
      
      // Configurar metadados b√°sicos
      SettableMetadata metadata = SettableMetadata(
        contentType: 'image/png',
        customMetadata: {
          'uploadedBy': userId,
          'uploadedAt': timestamp.toString(),
          'fileType': 'story_image',
        },
      );
      
      print('DEBUG REPO: Iniciando upload...');
      
      // Fazer upload simples
      final uploadTask = ref.putData(fileData, metadata);
      
      // Aguardar conclus√£o com timeout
      final snapshot = await uploadTask.timeout(
        const Duration(minutes: 5),
        onTimeout: () {
          uploadTask.cancel();
          throw Exception('Upload cancelado por timeout (5 minutos)');
        },
      );
      
      print('DEBUG REPO: Upload conclu√≠do. Estado: ${snapshot.state}');
      
      // Verificar se o upload foi bem-sucedido
      if (snapshot.state != TaskState.success) {
        throw Exception('Upload falhou. Estado: ${snapshot.state}');
      }
      
      // Obter URL de download
      String downloadUrl = await ref.getDownloadURL();
      
      print('DEBUG REPO: URL de download obtida: $downloadUrl');
      
      // Verificar se a URL √© v√°lida
      if (downloadUrl.isEmpty || !downloadUrl.startsWith('https://')) {
        throw Exception('URL de download inv√°lida: $downloadUrl');
      }
      
      return downloadUrl;
      
    } on FirebaseException catch (e) {
      print('DEBUG REPO: Erro do Firebase: ${e.code} - ${e.message}');
      
      // Tratar erros espec√≠ficos do Firebase de forma simples
      String errorMessage;
      switch (e.code) {
        case 'storage/unauthorized':
          errorMessage = 'ERRO DE AUTORIZA√á√ÉO:\n\n1. Usu√°rio n√£o est√° logado no Firebase\n2. Regras do Storage muito restritivas\n3. Token de autentica√ß√£o expirado\n\nTente fazer login novamente.';
          break;
        case 'storage/canceled':
          errorMessage = 'Upload cancelado pelo usu√°rio.';
          break;
        case 'storage/unknown':
          errorMessage = 'Erro desconhecido do Firebase Storage. Tente novamente.';
          break;
        case 'storage/quota-exceeded':
          errorMessage = 'Cota de armazenamento excedida. Contate o administrador.';
          break;
        default:
          errorMessage = 'Erro do Firebase Storage: ${e.message ?? e.code}';
      }
      throw Exception(errorMessage);
      
    } catch (e, stackTrace) {
      debugPrint('DEBUG REPO: Erro geral no upload: $e');
      
      // Tratar outros tipos de erro de forma simples
      if (e.toString().contains('timeout')) {
        throw Exception('Upload demorou muito. Verifique sua conex√£o e tente novamente.');
      } else if (e.toString().contains('network')) {
        throw Exception('Erro de rede. Verifique sua conex√£o com a internet.');
      } else {
        throw Exception('Erro ao fazer upload: ${e.toString()}');
      }
    }
  }
  

  
  static void _validateImageData(Uint8List fileData) {
    if (fileData.isEmpty) {
      throw ArgumentError('Image data cannot be empty');
    }
    
    if (fileData.length < 100) {
      throw ArgumentError('Image data too small, possibly corrupted');
    }
    
    if (fileData.length > 50 * 1024 * 1024) { // 50MB max
      throw ArgumentError('Image data too large (max 50MB)');
    }
    
    // Verificar assinatura b√°sica de imagem
    if (!_hasValidImageSignature(fileData)) {
      throw ArgumentError('Invalid image format or corrupted data');
    }
  }
  
  static bool _hasValidImageSignature(Uint8List data) {
    if (data.length < 8) return false;
    
    // PNG signature: 89 50 4E 47 0D 0A 1A 0A
    if (data[0] == 0x89 && data[1] == 0x50 && data[2] == 0x4E && data[3] == 0x47) {
      return true;
    }
    
    // JPEG signature: FF D8 FF
    if (data[0] == 0xFF && data[1] == 0xD8 && data[2] == 0xFF) {
      return true;
    }
    
    // GIF signature: GIF87a or GIF89a
    if (data.length >= 6) {
      String header = String.fromCharCodes(data.sublist(0, 6));
      if (header == 'GIF87a' || header == 'GIF89a') {
        return true;
      }
    }
    
    // WEBP signature: RIFF....WEBP
    if (data.length >= 12) {
      if (data[0] == 0x52 && data[1] == 0x49 && data[2] == 0x46 && data[3] == 0x46 &&
          data[8] == 0x57 && data[9] == 0x45 && data[10] == 0x42 && data[11] == 0x50) {
        return true;
      }
    }
    
    return false;
  }
  
  static String _generateRandomString(int length) {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    final random = DateTime.now().millisecondsSinceEpoch;
    return List.generate(length, (index) => chars[(random + index) % chars.length]).join();
  }
  
  static Future<void> _verifyUploadedFile(Reference ref, int expectedSize) async {
    try {
      FullMetadata metadata = await ref.getMetadata();
      
      if (metadata.size == null) {
        throw Exception('Could not verify uploaded file size');
      }
      
      if (metadata.size! != expectedSize) {
        throw Exception('Uploaded file size mismatch: expected $expectedSize, got ${metadata.size}');
      }
      
      DebugLogger.debug('StoriesRepository', 'file_verification_passed', {
        'expectedSize': expectedSize,
        'actualSize': metadata.size,
        'contentType': metadata.contentType
      });
      
    } catch (e) {
      DebugLogger.error('StoriesRepository', 'file_verification_error', e.toString());
      rethrow;
    }
  }

  static Future<String> _uploadVideo(File file) async {
    print('DEBUG REPO: Iniciando upload de v√≠deo');
    print('DEBUG REPO: Caminho do arquivo: ${file.path}');

    try {
      // Verificar se o usu√°rio est√° autenticado
      final user = FirebaseAuth.instance.currentUser;
      if (user == null) {
        throw Exception('Usu√°rio n√£o autenticado. Fa√ßa login novamente.');
      }
      
      // Verificar se o arquivo existe
      if (!await file.exists()) {
        throw Exception('Arquivo de v√≠deo n√£o encontrado');
      }
      
      // Verificar tamanho do arquivo
      final fileSize = await file.length();
      print('DEBUG REPO: Tamanho do v√≠deo: ${fileSize} bytes');
      
      if (fileSize == 0) {
        throw Exception('Arquivo de v√≠deo est√° vazio');
      }
      
      if (fileSize > 100 * 1024 * 1024) { // 100MB max para v√≠deos
        throw Exception('V√≠deo muito grande (m√°ximo 100MB)');
      }
      
      // Gerar nome √∫nico para o arquivo
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final userId = user.uid;
      final fileName = 'stories_files/${userId}_${timestamp}.mp4';
      
      print('DEBUG REPO: Nome do arquivo: $fileName');
      
      // Criar refer√™ncia do Firebase Storage
      Reference ref = FirebaseStorage.instance.ref().child(fileName);
      
      // Configurar metadados
      SettableMetadata metadata = SettableMetadata(
        contentType: 'video/mp4',
        customMetadata: {
          'uploadedBy': userId,
          'uploadedAt': timestamp.toString(),
          'fileType': 'story_video',
          'fileSize': fileSize.toString(),
        },
      );
      
      print('DEBUG REPO: Iniciando upload do v√≠deo...');
      
      // Fazer upload com monitoramento
      final uploadTask = ref.putFile(file, metadata);
      
      // Monitorar progresso
      uploadTask.snapshotEvents.listen((TaskSnapshot snapshot) {
        double progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
        print('DEBUG REPO: Progresso do upload do v√≠deo: ${progress.toStringAsFixed(1)}%');
      });
      
      // Aguardar conclus√£o com timeout maior para v√≠deos
      final snapshot = await uploadTask.timeout(
        const Duration(minutes: 10),
        onTimeout: () {
          uploadTask.cancel();
          throw Exception('Upload do v√≠deo cancelado por timeout (10 minutos)');
        },
      );
      
      print('DEBUG REPO: Upload do v√≠deo conclu√≠do. Estado: ${snapshot.state}');
      
      // Verificar se o upload foi bem-sucedido
      if (snapshot.state != TaskState.success) {
        throw Exception('Upload do v√≠deo falhou. Estado: ${snapshot.state}');
      }
      
      // Obter URL de download
      String downloadUrl = await ref.getDownloadURL();
      
      print('DEBUG REPO: URL de download do v√≠deo: $downloadUrl');
      
      // Verificar se a URL √© v√°lida
      if (downloadUrl.isEmpty || !downloadUrl.startsWith('https://')) {
        throw Exception('URL de download do v√≠deo inv√°lida: $downloadUrl');
      }
      
      return downloadUrl;
      
    } on FirebaseException catch (e) {
      print('DEBUG REPO: Erro do Firebase no upload do v√≠deo: ${e.code} - ${e.message}');
      
      // Tratar erros espec√≠ficos do Firebase
      switch (e.code) {
        case 'storage/unauthorized':
          throw Exception('Sem permiss√£o para fazer upload de v√≠deo. Verifique as configura√ß√µes do Firebase.');
        case 'storage/canceled':
          throw Exception('Upload do v√≠deo cancelado pelo usu√°rio.');
        case 'storage/unknown':
          throw Exception('Erro desconhecido do Firebase Storage no upload do v√≠deo. Tente novamente.');
        case 'storage/invalid-format':
          throw Exception('Formato de v√≠deo inv√°lido.');
        case 'storage/quota-exceeded':
          throw Exception('Cota de armazenamento excedida para v√≠deos.');
        default:
          throw Exception('Erro do Firebase Storage no v√≠deo: ${e.message ?? e.code}');
      }
    } catch (e, stackTrace) {
      print('DEBUG REPO: Erro geral no upload do v√≠deo: $e');
      print('DEBUG REPO: Stack trace: $stackTrace');
      
      // Tratar outros tipos de erro
      if (e.toString().contains('timeout')) {
        throw Exception('Upload do v√≠deo demorou muito. Verifique sua conex√£o e tente novamente.');
      } else if (e.toString().contains('network')) {
        throw Exception('Erro de rede no upload do v√≠deo. Verifique sua conex√£o com a internet.');
      } else {
        throw Exception('Erro ao fazer upload do v√≠deo: ${e.toString()}');
      }
    }
  }

  static Future<void> delete({
    required String id,
    String? contexto
  }) async {
    DebugLogger.info('StoriesRepository', 'delete_start', {
      'documentId': id,
      'contexto': contexto
    });
    
    String? deletedFromContext;
    
    try {
      if(contexto == null) {
        // Tentar deletar de ambas as cole√ß√µes se o contexto n√£o for especificado
        try {
          await FirebaseFirestore.instance.collection('stories_files').doc(id).delete();
          deletedFromContext = 'principal';
          DebugLogger.success('StoriesRepository', 'delete_success', {
            'documentId': id,
            'collection': 'stories_files'
          });
        } catch (e) {
          await FirebaseFirestore.instance.collection('stories_sinais_isaque').doc(id).delete();
          deletedFromContext = 'sinais_isaque';
          DebugLogger.success('StoriesRepository', 'delete_success', {
            'documentId': id,
            'collection': 'stories_sinais_isaque'
          });
        }
      } else {
        String colecao;
        switch (contexto) {
          case 'sinais_isaque':
            colecao = 'stories_sinais_isaque';
            break;
          case 'sinais_rebeca':
            colecao = 'stories_sinais_rebeca';
            break;
          case 'nosso_proposito':
            colecao = 'stories_nosso_proposito';
            break;
          default:
            colecao = 'stories_files';
        }
        await FirebaseFirestore.instance.collection(colecao).doc(id).delete();
        deletedFromContext = contexto;
        DebugLogger.success('StoriesRepository', 'delete_success', {
          'documentId': id,
          'collection': colecao,
          'contexto': contexto
        });
      }
      
      // Notificar controller da galeria sobre story deletado
      try {
        if (Get.isRegistered<StoriesGalleryController>()) {
          if (deletedFromContext != null) {
            StoriesGalleryController.instance.notifyStoryDeleted(deletedFromContext);
          }
        }
      } catch (e) {
        DebugLogger.error('StoriesRepository', 'delete_notification_error', e.toString());
      }
      
    } catch (e, stackTrace) {
      DebugLogger.error('StoriesRepository', 'delete_error', e.toString(), {
        'documentId': id,
        'contexto': contexto,
        'stackTrace': stackTrace.toString()
      });
      rethrow;
    }
  }

  // ========== M√âTODOS DE HIST√ìRICO ==========

  /// Obt√©m stories do hist√≥rico do usu√°rio
  static Future<List<StorieFileModel>> getHistoryStories({
    int limit = 50,
    String? lastDocumentId,
  }) async {
    try {
      print('üìö REPO: Carregando stories do hist√≥rico');
      
      final historyData = await _historyService.getHistoryStories(
        limit: limit,
        lastDocumentId: lastDocumentId,
      );
      
      List<StorieFileModel> stories = [];
      for (var data in historyData) {
        try {
          StorieFileModel story = StorieFileModel.fromJson(data);
          story.id = data['id'];
          stories.add(story);
        } catch (e) {
          print('DEBUG REPO: Erro ao processar story do hist√≥rico: $e');
        }
      }
      
      print('üìö REPO: Carregados ${stories.length} stories do hist√≥rico');
      return stories;
    } catch (e) {
      print('‚ùå REPO: Erro ao carregar hist√≥rico: $e');
      return [];
    }
  }

  /// Move um story espec√≠fico para o hist√≥rico
  static Future<void> moveStoryToHistory(String storyId, String contexto) async {
    try {
      print('üì¶ REPO: Movendo story $storyId para hist√≥rico');
      
      String colecao;
      switch (contexto) {
        case 'sinais_isaque':
          colecao = 'stories_sinais_isaque';
          break;
        case 'sinais_rebeca':
          colecao = 'stories_sinais_rebeca';
          break;
        case 'nosso_proposito':
          colecao = 'stories_nosso_proposito';
          break;
        default:
          colecao = 'stories_files';
      }
      
      // Obter dados do story
      final doc = await FirebaseFirestore.instance
          .collection(colecao)
          .doc(storyId)
          .get();
      
      if (!doc.exists) {
        throw Exception('Story n√£o encontrado');
      }
      
      // Mover para hist√≥rico
      await _historyService.moveStoryToHistory(
        storyId,
        colecao,
        doc.data()!,
      );
      
      print('‚úÖ REPO: Story movido para hist√≥rico com sucesso');
    } catch (e) {
      print('‚ùå REPO: Erro ao mover story para hist√≥rico: $e');
      rethrow;
    }
  }

  /// Executa migra√ß√£o manual de stories expirados
  static Future<void> migrateExpiredStories() async {
    try {
      print('üîÑ REPO: Iniciando migra√ß√£o manual de stories expirados');
      await _historyService.moveExpiredStoriesToHistory();
      print('‚úÖ REPO: Migra√ß√£o conclu√≠da');
    } catch (e) {
      print('‚ùå REPO: Erro na migra√ß√£o: $e');
      rethrow;
    }
  }

  /// Limpa stories antigos do hist√≥rico
  static Future<void> cleanOldHistoryStories({int daysToKeep = 30}) async {
    try {
      print('üßπ REPO: Limpando hist√≥rico antigo (>${daysToKeep} dias)');
      await _historyService.cleanOldHistoryStories(daysToKeep: daysToKeep);
      print('‚úÖ REPO: Limpeza do hist√≥rico conclu√≠da');
    } catch (e) {
      print('‚ùå REPO: Erro na limpeza do hist√≥rico: $e');
      rethrow;
    }
  }

  /// Restaura um story do hist√≥rico
  static Future<void> restoreStoryFromHistory(String historyStoryId) async {
    try {
      print('üîÑ REPO: Restaurando story $historyStoryId do hist√≥rico');
      await _historyService.restoreStoryFromHistory(historyStoryId);
      print('‚úÖ REPO: Story restaurado com sucesso');
    } catch (e) {
      print('‚ùå REPO: Erro ao restaurar story: $e');
      rethrow;
    }
  }
}